import{_ as e,o as t,c as n,d as a}from"./app.40b47211.js";const f=JSON.parse(`{"title":"ARS ~ Intuition","description":"","frontmatter":{"title":"ARS ~ Intuition","layout":"doc"},"headers":[{"level":2,"title":"Problem : Relations requirements","slug":"problem-relations-requirements","link":"#problem-relations-requirements","children":[]},{"level":2,"title":"Vuethers' approach","slug":"vuethers-approach","link":"#vuethers-approach","children":[]}],"relativePath":"guide/ars/intuition.md"}`),o={name:"guide/ars/intuition.md"},r=a('<h1 id="intuition" tabindex="-1">Intuition <a class="header-anchor" href="#intuition" aria-hidden="true">#</a></h1><p>Creating a DApp frontend implies having to deal with many distinct but intimately related concepts like : providers, signers, contracts, transactions, etc.</p><p>When working with <a href="https://ethers.org/" target="_blank" rel="noreferrer">Ethers.js</a> for example, we firstly have to instanciate one of the <code>Provider</code> classes that represent the network (chain) our DApp is working with.</p><p>Once done we will be able to instanciate one of the <code>Signer</code> classes that will represent the wallet connected to our DApp.</p><p>Finally we are able to create <code>Contract</code> instances to interact with on-chain contracts through simple JS interfaces and we implicitly create <code>Transaction</code> instances when calling one of the contracts methods.</p><h2 id="problem-relations-requirements" tabindex="-1">Problem : Relations requirements <a class="header-anchor" href="#problem-relations-requirements" aria-hidden="true">#</a></h2><p>All of those objects are distinct but at the same time intimately related. Here are some of the relations we can observe between them :</p><ul><li>signers require a valid <code>Provider</code> instance to work properly</li><li>contracts&#39; interactions will not work without a valid <code>Provider</code> or <code>Signer</code> instance</li><li>when the signer changes, contracts must be updated with the new <code>Signer</code> instance</li><li>when the signer is removed, contracts must be linked back to the valid <code>Provider</code> instance (if there is one)</li><li>when provider changes, the DApp must be refreshed in order to safely re-initialize all other instances</li></ul><p>In order to create a safe DApp environment, those relations requirements must be strongly managed, and an instance change should conduces to an update of all instances that depends on it.</p><p>In other words it means that some pieces of code have to monitor these changes and to perform the required operations when they occur.</p><p>Creating such a safe system is an heavy task and DApp developers loose a lot of time</p><h2 id="vuethers-approach" tabindex="-1">Vuethers&#39; approach <a class="header-anchor" href="#vuethers-approach" aria-hidden="true">#</a></h2><p>In order to provides developers with an always-safe environment, Vuethers introduces the ARS (Automated Relation Safety) system.</p><p>With the ARS you don&#39;t have anymore to think about &quot;<em>Have I updated my contract with the new signer ?</em>&quot; or &quot;<em>What should I do if the network changes ?</em>&quot; all those problems are internally and transparently managed by Vuethers.</p><p>Just relax, and enjoy your DApp frontend development ! <span style="font-size:20px;">\u{1F43B}</span></p>',15),i=[r];function s(c,l,h,d,p,u){return t(),n("div",null,i)}const w=e(o,[["render",s]]);export{f as __pageData,w as default};
