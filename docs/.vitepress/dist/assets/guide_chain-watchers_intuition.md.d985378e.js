import{_ as e,o as t,c as a,d as i}from"./app.687a42d7.js";const f=JSON.parse(`{"title":"Chain watchers ~ Intuition","description":"","frontmatter":{"title":"Chain watchers ~ Intuition","layout":"doc"},"headers":[{"level":2,"title":"Problem","slug":"problem","link":"#problem","children":[]},{"level":2,"title":"Tulipe' approach","slug":"tulipe-approach","link":"#tulipe-approach","children":[]}],"relativePath":"guide/chain-watchers/intuition.md"}`),o={name:"guide/chain-watchers/intuition.md"},n=i('<h1 id="intuition" tabindex="-1">Intuition <a class="header-anchor" href="#intuition" aria-hidden="true">#</a></h1><p>When developing reactive web DApps we need to regularly fetch datas from the chain to always display the most up-to-date ones to the user.</p><p>A raw way to achieve that is to create a while loop for each data we want to track to request every X seconds the chain for that data.</p><p>However this method has a major problem, even for tiny projects we quickly end with tens of infinite loops running in background which can affects a lot the performances of our app. In addition, this raw way implies that developers write 50+ times this while loop and all code required to make it safe in the project, which leads to more complex and so less maintainable code.</p><p>Assuming that mutation of datas on chain requires a new block, a smarter way to achieve that is to create <strong>a single</strong> infinite loop that checks every X seconds if the block number has changed, and if it has, only then it fetches all the datas required by the DApp.</p><p><strong>This drastically reduces the number of requests</strong> and so improves a lot performances.</p><p>A way to improves even more this system is to associate a contract or wallet address to each data, and to update it only if its associated address appears in the new block&#39;s transactions. This again drastically reduces the number of requests.</p><p>Also if multiple places of our DApp are tracking the same data we can group them and perform only one chain request to update them all.</p><h2 id="problem" tabindex="-1">Problem <a class="header-anchor" href="#problem" aria-hidden="true">#</a></h2><p><a href="https://trufflesuite.com/drizzle/" target="_blank" rel="noreferrer">Drizzle</a> was a JS tool that was providing such a system, however it is not updated since Sep, 2020 (at writing time) and its VueJS version is based on the deprecated Vuex store.</p><p>Also, in my own opinion, this tool is much more complex than it should be.</p><h2 id="tulipe-approach" tabindex="-1">Tulipe&#39; approach <a class="header-anchor" href="#tulipe-approach" aria-hidden="true">#</a></h2><p>To solve that problem Tulipe&#39; introduces <strong>chain watchers</strong> They provides a way to easily watch any on-chain data and <strong>it feels like watching any ref in Vue !</strong></p><p>So thanks to Tulipe you can now watch any on-chain data in an intuitive and simple way : only one method call is required.</p>',14),r=[n];function s(h,c,l,p,d,u){return t(),a("div",null,r)}const w=e(o,[["render",s]]);export{f as __pageData,w as default};
